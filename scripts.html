<script>
function toggleImage(img) {
if (img.classList.contains('enlarged')) {
// Restore to original position and size
 img.style.position = '';
 img.style.top = '';
 img.style.left = '';
 img.style.transform = '';
 img.style.zIndex = '';
 img.style.boxShadow = '';
 img.style.maxWidth = '';
 img.style.maxHeight = '';
 img.style.width = '';
 img.style.height = '';
 img.classList.remove('enlarged');
// Restore original width
if (img.dataset.originalWidth) {
 img.style.width = img.dataset.originalWidth;
 }
// Move back to original parent
if (img.dataset.originalParent) {
const originalParent = document.querySelector(`[data-original-id="${img.dataset.originalParent}"]`);
if (originalParent) {
 originalParent.appendChild(img);
 }
 }
// Clean up
delete img.dataset.originalParent;
delete img.dataset.originalWidth;
 } else {
// Store original width
 img.dataset.originalWidth = img.style.width || '';
// Store reference to original parent
const originalParent = img.parentElement;
 originalParent.setAttribute('data-original-id', Date.now());
 img.dataset.originalParent = originalParent.getAttribute('data-original-id');
// Enlarge and move to body level with viewport constraints
 img.style.position = 'fixed';
 img.style.top = '50%';
 img.style.left = '50%';
 img.style.transform = 'translate(-50%, -50%)';
 img.style.maxWidth = '90vw';
 img.style.maxHeight = '90vh';
 img.style.width = 'auto';
 img.style.height = 'auto';
 img.style.zIndex = '2147483647';
 img.style.boxShadow = '0 10px 30px rgba(0,0,0,0.5)';
 img.classList.add('enlarged');
 document.body.appendChild(img);
 }
}

// === ROADMAP FUNCTIONALITY ===
// Only load Plotly on roadmap page to avoid conflicts
if (document.getElementById('roadmap-summary')) {
  // Load Plotly.js dynamically
  const script = document.createElement('script');
  script.src = 'https://cdn.plot.ly/plotly-3.0.1.min.js';
  script.onload = function() {
    console.log('Plotly 3.0.1 loaded successfully');
    initializeRoadmap();
  };
  script.onerror = function() {
    console.error('Failed to load Plotly');
    document.getElementById('roadmap-summary').innerHTML = '<p>Failed to load charting library</p>';
  };
  document.head.appendChild(script);
}

function initializeRoadmap() {
  console.log('Initializing roadmap...');
  
  // Function to create summary statistics
  function createSummary(issues) {
    const totalIssues = issues.length;
    const uniqueLabels = new Set();
    let totalLabels = 0;
    
    issues.forEach(issue => {
      const labels = issue.labels || [];
      labels.forEach(label => {
        uniqueLabels.add(label);
        totalLabels++;
      });
    });
    
    const avgLabelsPerIssue = totalIssues > 0 ? (totalLabels / totalIssues).toFixed(1) : 0;
    
    return {
      totalIssues,
      uniqueLabels: uniqueLabels.size,
      avgLabelsPerIssue
    };
  }

  // Function to count issues by creation date and state
  function countIssuesByDateAndState(issues) {
    const openData = {};
    const closedData = {};
    
    issues.forEach(issue => {
      const date = new Date(issue.created_at).toISOString().split('T')[0]; // YYYY-MM-DD
      const state = issue.state;
      const title = issue.title;
      
      if (state === 'open') {
        if (!openData[date]) {
          openData[date] = { count: 0, titles: [] };
        }
        openData[date].count++;
        openData[date].titles.push(title);
      } else if (state === 'closed') {
        if (!closedData[date]) {
          closedData[date] = { count: 0, titles: [] };
        }
        closedData[date].count++;
        closedData[date].titles.push(title);
      }
    });
    
    // Get all unique dates and sort them
    const allDates = Array.from(new Set([
      ...Object.keys(openData),
      ...Object.keys(closedData)
    ])).sort();
    
    // Build arrays with cumulative counts
    let openCumulative = 0;
    let closedCumulative = 0;
    
    const openCounts = [];
    const closedCounts = [];
    const openTitles = [];
    const closedTitles = [];
    
    allDates.forEach(date => {
      // Add daily counts to cumulative totals
      openCumulative += openData[date] ? openData[date].count : 0;
      closedCumulative += closedData[date] ? closedData[date].count : 0;
      
      openCounts.push(openCumulative);
      closedCounts.push(closedCumulative);
      
      // Collect titles for tooltips
      openTitles.push(openData[date] ? openData[date].titles : []);
      closedTitles.push(closedData[date] ? closedData[date].titles : []);
    });
    
    return {
      dates: allDates,
      open: { counts: openCounts, titles: openTitles },
      closed: { counts: closedCounts, titles: closedTitles }
    };
  }

  // Function to create timeline chart
  function createTimelineChart(dateData) {
    if (dateData.dates.length === 0) {
      document.getElementById('roadmap-timeline-chart').innerHTML = '<p>No date data available</p>';
      return;
    }
    
    console.log('Creating timeline chart with', dateData.dates.length, 'data points');
    
    // Create custom hover text for each point
    const openHoverText = dateData.dates.map((date, index) => {
      const titles = dateData.open.titles[index];
      if (titles.length === 0) return `<b>${date}</b><br>No open issues created`;
      
      const titlesList = titles.length > 3 
        ? titles.slice(0, 3).join('<br>') + `<br>... and ${titles.length - 3} more`
        : titles.join('<br>');
      
      return `<b>${date}</b><br>Open issues: ${titles.length}<br><br><i>Issues created:</i><br>${titlesList}`;
    });
    
    const closedHoverText = dateData.dates.map((date, index) => {
      const titles = dateData.closed.titles[index];
      if (titles.length === 0) return `<b>${date}</b><br>No closed issues created`;
      
      const titlesList = titles.length > 3 
        ? titles.slice(0, 3).join('<br>') + `<br>... and ${titles.length - 3} more`
        : titles.join('<br>');
      
      return `<b>${date}</b><br>Closed issues: ${titles.length}<br><br><i>Issues created:</i><br>${titlesList}`;
    });
    
    const data = [
      {
        type: 'scatter',
        mode: 'lines+markers',
        x: dateData.dates,
        y: dateData.open.counts,
        name: 'Open Issues',
        marker: {
          color: '#4285F4', // Blue
          size: 6
        },
        line: {
          color: '#4285F4',
          width: 3
        },
        hovertemplate: '%{hovertext}<extra></extra>',
        hovertext: openHoverText
      },
      {
        type: 'scatter',
        mode: 'lines+markers',
        x: dateData.dates,
        y: dateData.closed.counts,
        name: 'Closed Issues',
        marker: {
          color: '#FF8C00', // Orange
          size: 6
        },
        line: {
          color: '#FF8C00',
          width: 3
        },
        hovertemplate: '%{hovertext}<extra></extra>',
        hovertext: closedHoverText
      }
    ];
    
    const layout = {
      title: 'Cumulative Issues Created Over Time',
      xaxis: { 
        title: 'Date',
        type: 'date'
      },
      yaxis: { 
        title: 'Cumulative Number of Issues'
      },
      margin: { t: 60, b: 80, l: 60, r: 40 },
      showlegend: true,
      legend: {
        orientation: 'h',
        y: -0.2
      }
    };
    
    const config = { displayModeBar: false };
    
    Plotly.newPlot('roadmap-timeline-chart', data, layout, config);
  }

  // Function to count label frequency
  function countLabels(issues) {
    const labelCounts = {};
    
    issues.forEach(issue => {
      const labels = issue.labels || [];
      labels.forEach(label => {
        labelCounts[label] = (labelCounts[label] || 0) + 1;
      });
    });
    
    return labelCounts;
  }

  // Function to create pie chart
  function createPieChart(labelCounts) {
    const labels = Object.keys(labelCounts);
    const counts = Object.values(labelCounts);
    
    if (labels.length === 0) {
      document.getElementById('roadmap-pie-chart').innerHTML = '<p>No labels found</p>';
      return;
    }
    
    console.log('Creating pie chart with', labels.length, 'labels');
    
    const data = [{
      type: 'pie',
      labels: labels,
      values: counts,
      hovertemplate: '<b>%{label}</b><br>' +
                     'Issues: %{value}<br>' +
                     'Percentage: %{percent}<br>' +
                     '<extra></extra>'
    }];
    
    const layout = {
      title: 'Issue Distribution by Label',
      margin: { t: 60, b: 40, l: 40, r: 40 }
    };
    
    const config = { displayModeBar: false };
    
    Plotly.newPlot('roadmap-pie-chart', data, layout, config);
  }

  // Function to create bar chart
  function createBarChart(labelCounts) {
    const labels = Object.keys(labelCounts);
    const counts = Object.values(labelCounts);
    
    if (labels.length === 0) {
      document.getElementById('roadmap-bar-chart').innerHTML = '<p>No labels found</p>';
      return;
    }
    
    console.log('Creating bar chart with', labels.length, 'labels');
    
    const data = [{
      type: 'bar',
      x: labels,
      y: counts,
      marker: {
        color: '#4ECDC4'
      }
    }];
    
    const layout = {
      title: 'Issue Count by Label',
      xaxis: { title: 'Labels' },
      yaxis: { title: 'Number of Issues' },
      margin: { t: 60, b: 100, l: 60, r: 40 }
    };
    
    const config = { displayModeBar: false };
    
    Plotly.newPlot('roadmap-bar-chart', data, layout, config);
  }

  // Load and process data
  async function loadRoadmapData() {
    console.log('Attempting to load roadmap data...');
    console.log('Current URL:', window.location.href);
    console.log('Current pathname:', window.location.pathname);
    
    // Show loading state
    document.getElementById('roadmap-summary').innerHTML = '<p>Loading issue data...</p>';
    document.getElementById('roadmap-timeline-chart').innerHTML = '<p>Loading timeline chart...</p>';
    document.getElementById('roadmap-pie-chart').innerHTML = '<p>Loading pie chart...</p>';
    document.getElementById('roadmap-bar-chart').innerHTML = '<p>Loading bar chart...</p>';
    
    // Try multiple possible paths for the issues.json file
    const possiblePaths = [
      'issues.json',           // Site root
      '/vandalizer-manual/issues.json',  // Absolute path based on your URL
      './issues.json',         // Relative to current page
      '../issues.json',        // Parent directory
      '/issues.json',          // Absolute site root
      'data/issues.json',      // In a data folder
      '_site/issues.json'      // In _site folder
    ];
    
    let issues = null;
    let successfulPath = null;
    
    for (const path of possiblePaths) {
      try {
        console.log(`Trying to fetch from: ${path}`);
        const fullUrl = new URL(path, window.location.href);
        console.log(`Full URL: ${fullUrl.href}`);
        
        const response = await fetch(path);
        
        console.log(`Response status: ${response.status} ${response.statusText}`);
        console.log(`Response URL: ${response.url}`);
        
        if (response.ok) {
          console.log(`✓ Successfully fetched from: ${path}`);
          console.log('Response headers:', response.headers.get('content-type'));
          
          const text = await response.text();
          console.log('Response content length:', text.length);
          console.log('First 200 characters:', text.substring(0, 200));
          
          try {
            issues = JSON.parse(text);
            console.log(`✓ Successfully parsed ${issues.length} issues from JSON array`);
            successfulPath = path;
            break;
          } catch (jsonError) {
            console.log(`✗ JSON parsing failed for ${path}:`, jsonError.message);
            
            // Try parsing as concatenated JSON objects (fallback for old format)
            try {
              console.log('Attempting to parse as concatenated JSON objects...');
              
              // Split on }{ pattern and add proper separators
              let fixedJson = text.trim();
              
              // Replace }\n{ or }{ with },\n{
              fixedJson = fixedJson.replace(/\}\s*\{/g, '},\n{');
              
              // Wrap in array brackets
              fixedJson = '[' + fixedJson + ']';
              
              console.log('Fixed JSON first 200 chars:', fixedJson.substring(0, 200));
              
              issues = JSON.parse(fixedJson);
              console.log(`✓ Successfully parsed ${issues.length} issues from concatenated JSON`);
              successfulPath = path;
              break;
            } catch (fixError) {
              console.log(`✗ Concatenated JSON parsing also failed for ${path}:`, fixError.message);
              console.log('Response content (first 500 chars):', text.substring(0, 500));
              continue;
            }
          }
        } else {
          console.log(`✗ Failed to fetch from ${path}: ${response.status} - ${response.statusText}`);
        }
      } catch (error) {
        console.log(`✗ Error fetching from ${path}:`, error.message);
      }
    }
    
    if (!issues) {
      const errorMessage = 'Could not find issues.json file in any of the expected locations';
      console.error(errorMessage);
      document.getElementById('roadmap-summary').innerHTML = `<p>Error: ${errorMessage}</p>`;
      document.getElementById('roadmap-timeline-chart').innerHTML = '<p>Could not load chart - see console for details</p>';
      document.getElementById('roadmap-pie-chart').innerHTML = '<p>Could not load chart - see console for details</p>';
      document.getElementById('roadmap-bar-chart').innerHTML = '<p>Could not load chart - see console for details</p>';
      return;
    }
    
    console.log(`Successfully loaded ${issues.length} issues from: ${successfulPath}`);
      
    if (issues.length === 0) {
      const noDataMessage = '<p>No issues data available (file loaded but empty)</p>';
      document.getElementById('roadmap-summary').innerHTML = noDataMessage;
      document.getElementById('roadmap-timeline-chart').innerHTML = noDataMessage;
      document.getElementById('roadmap-pie-chart').innerHTML = noDataMessage;
      document.getElementById('roadmap-bar-chart').innerHTML = noDataMessage;
      return;
    }
    
    try {
      console.log('Processing data and creating visualizations...');
      
      // Create summary
      const summary = createSummary(issues);
      document.getElementById('roadmap-summary').innerHTML = `
        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px; margin-bottom: 20px;">
          <div style="text-align: center; padding: 15px; background: #f8f9fa; border-radius: 8px;">
            <h3 style="margin: 0; color: #4ECDC4;">${summary.totalIssues}</h3>
            <p style="margin: 5px 0 0 0;">Open Issues</p>
          </div>
          <div style="text-align: center; padding: 15px; background: #f8f9fa; border-radius: 8px;">
            <h3 style="margin: 0; color: #4ECDC4;">${summary.uniqueLabels}</h3>
            <p style="margin: 5px 0 0 0;">Unique Labels</p>
          </div>
          <div style="text-align: center; padding: 15px; background: #f8f9fa; border-radius: 8px;">
            <h3 style="margin: 0; color: #4ECDC4;">${summary.avgLabelsPerIssue}</h3>
            <p style="margin: 5px 0 0 0;">Avg Labels per Issue</p>
          </div>
        </div>
      `;
      
      // Create timeline chart
      const dateData = countIssuesByDateAndState(issues);
      createTimelineChart(dateData);
      
      // Create label charts
      const labelCounts = countLabels(issues);
      createPieChart(labelCounts);
      createBarChart(labelCounts);
      
      console.log('Roadmap visualization complete!');
      
    } catch (error) {
      console.error('Error in roadmap processing:', error);
      const errorMessage = `<p>Error processing roadmap: ${error.message}</p>`;
      document.getElementById('roadmap-summary').innerHTML = errorMessage;
      document.getElementById('roadmap-timeline-chart').innerHTML = '<p>Could not load chart - see console for details</p>';
      document.getElementById('roadmap-pie-chart').innerHTML = '<p>Could not load chart - see console for details</p>';
      document.getElementById('roadmap-bar-chart').innerHTML = '<p>Could not load chart - see console for details</p>';
    }
  }

  // Load roadmap data
  loadRoadmapData();
}
</script>
